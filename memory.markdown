# Linux 的内存基础 #

## 地址类型 ##
linux内核中有许多种不同的地址类型

* 用户虚拟地址
用户空间看到的常规地址，通过页表可以将虚拟地址和物理地址映射起来
* 物理地址
用在cpu和内存之间的地址叫做物理地址
* 总线地址
外围总线和内存之间的地址叫做总线地址。通常他们和物理地址相同
* 内核逻辑地址
内核的常规地址空间，必定有对应的物理内存与之映射。kmalloc返回的就是内核逻辑地址
* 内核虚拟地址
内核虚拟地址和内核逻辑地址的相同之处在于，他们都将内核空间的地址映射到物理内存上。但是内核虚拟地址不一定是线性的和一对一的。vmalloc返回的是虚拟地址。

## 物理地址和页 ##

物理地址被分成离散的单元，成为页。目前大多数系统的页面大小都为4k。实际使用的时候应该使用指定体系架构下的页面大小PAGE\_SIZE。PAGE\_SHIFT可以将地址转换为页帧。

## 高端和低端内存 ##

系统中逻辑地址和虚拟地址不一致的情况产生了高端内存和低端内存的说法。

通常内核将4GB的虚拟地址分割为用户空间和内核空间；在二者的上下文中使用相同的映射。一个典型的分配是将3GB分给用户空间，将剩下的1GB分给内核空间。这样由于内核只能直接操作已经映射了物理内存的虚拟地址，所以内核在达内存系统中就不能直接访问所有的物理内存。这样就产生了高端内存和低端内存的说法。

在访问特定的高端内存之前，内核必须建立明确的虚拟映射，使该页可以在内核地址空间被访问。

总的来说高端内存就是没有逻辑地址的内存，反之就是低端内存。

## 内存映射和结构 ##

由于高端内存中无法使用逻辑地址，所以内核中处理内存的函数趋向于使用指向page结构的指针。该结构保存了内核需要知道的所有物理内存的信息。系统中的每个物理页都和一个page结构对应。

page结构和虚拟地址之间转换的函数和宏：

* struct page \*virt\_to\_page(void \*kaddr);
* struct page \*pfn\_to\_page(int pfn);
* void \*page_addr(struct page \*page);

## 页表 ##

现代系统中，处理器需要使用某种机制将虚拟地址转换成物理地址。这种机制被成为页表；它基本上是一个多层树形结构，结构化的数组中包含了虚拟地址到物理地址的映射和相关的标志位。


## 虚拟内存区 ##

VMA是用于管理进程地址空间中不同区域的内核数据结构。

进程的内存映射至少包含下面这些区域：

* 程序可执行代码区域（text）
* 数据区（bss，stack，data）
* 与每个活动的内存映射区对应的区域

可以`cat /proc/<pid/maps>`来查看具体进程的内存映射。

当用户空间进程调用mmap时，系统会创建一个新的VMA来相应它。

注意vm\_area\_struct这个重要的数据结构（定义在<linux/mm.h>中）。

## 内存映射处理 ##

系统中每个进程（除了内核空间的辅助线程）都有一个struct mm_struct结构（定义在<linux/sched.h>中），其中包含了大量的内存管理信息。多个进程可以共享内存管理结构，linux就是使用这种方法实现线程的。

## mmap设备操作 ##

mmap可以将用户空间的内存和设备内存映射起来，这样在访问分配地址范围内的内存时就相当于访问设备内存了。

并非所有的设备都能进行mmap抽象：

* 像串口这样面向流的设备就不能
* mmap的另一个限制：必须以PAGE_SIZE为单位进行映射，因为内核只能在页表一级上对虚拟地址进行管理。

为了执行mmpa，驱动程序只需要为该地址范围建立合适的页表，并将vma->vm_ops替换为一系列的新操作就可以了。有两种建立页表的方法：使用remap\_pfn\_range函数一次全部建立；通过VMA的fault方法一次建立一个新页表。

## 内存映射的方法 ##

* 重新映射特定的I/O区域
* 重新映射ram
* 重新映射内核虚拟地址
* 执行直接I/O访问
