# Linux 内存基础 #

## 地址类型 ##
linux内核中有许多种不同的地址类型

* 用户虚拟地址
用户空间看到的常规地址，通过页表可以将虚拟地址和物理地址映射起来
* 物理地址
用在cpu和内存之间的地址叫做物理地址
* 总线地址
外围总线和内存之间的地址叫做总线地址。通常他们和物理地址相同
* 内核逻辑地址
内核的常规地址空间，必定有对应的物理内存与之映射。kmalloc返回的就是内核逻辑地址
* 内核虚拟地址
内核虚拟地址和内核逻辑地址的相同之处在于，他们都将内核空间的地址映射到物理内存上。但是内核虚拟地址不一定是线性的和一对一的。vmalloc返回的是虚拟地址。

## 虚拟内存 ##

虚拟内存是用来描述一种不直接映射计算机物理内存的方法。分页是在虚拟内存与物理内存转换时用到的。请参阅intel手册了解更多分页系统的知识。

低于896MB的每页内存都被直接映射到内核空间。高于896的内存，又称高端内存，不会一直映射到内存空间，而是使用kmap和kmap_atomic来临时映射。

内核内存从PAGE\_OFFSET开始，在x86架构中它的值是0xc0000000(3G)，高于PAGE\_OFFSET的虚拟内存用于内核空间，低于的用于用户空间。

### x86系统内存子系统初始化 ###

* 首先设置页表(可能有多级)
* 完成内核内存映射(内核中的物理内存和逻辑地址只有一个固定的OFFSET，PAGE\_OFFSET)

### 用户空间的内存管理 ###

* struct mm\_struct 进程内存空间的最高级别管理结构
* struct vm\_area\_struct 内存区域，组成进程内存
* pgd_t *pgd 进程页表指针

阅读ULK3学习更多内存管理的细节

## 物理地址和页 ##

物理地址被分成离散的单元，成为页。目前大多数系统的页面大小都为4k。实际使用的时候应该使用指定体系架构下的页面大小PAGE\_SIZE。PAGE\_SHIFT可以将地址转换为页帧。

## 高端和低端内存 ##

系统中逻辑地址和虚拟地址不一致的情况产生了高端内存和低端内存的说法。

通常内核将4GB的虚拟地址分割为用户空间和内核空间；在二者的上下文中使用相同的映射。一个典型的分配是将3GB分给用户空间，将剩下的1GB分给内核空间。这样由于内核只能直接操作已经映射了物理内存的虚拟地址，所以内核在大内存系统中就不能直接访问所有的物理内存。这样就产生了高端内存和低端内存的说法。

在访问特定的高端内存之前，内核必须建立明确的虚拟映射，使该页可以在内核地址空间被访问。

总的来说高端内存就是没有逻辑地址的内存，反之就是低端内存。

## 内存映射和结构 ##

由于高端内存中无法使用逻辑地址，所以内核中处理内存的函数趋向于使用指向page结构的指针。该结构保存了内核需要知道的所有物理内存的信息。系统中的每个物理页都和一个page结构对应。

page结构和虚拟地址之间转换的函数和宏：

* struct page \*virt\_to\_page(void \*kaddr);
* struct page \*pfn\_to\_page(int pfn);
* void \*page_addr(struct page \*page);

## 页表 ##

现代系统中，处理器需要使用某种机制将虚拟地址转换成物理地址。这种机制被成为页表；它基本上是一个多层树形结构，结构化的数组中包含了虚拟地址到物理地址的映射和相关的标志位。


## 虚拟内存区 ##

VMA是用于管理进程地址空间中不同区域的内核数据结构。

进程的内存映射至少包含下面这些区域：

* 程序可执行代码区域（text）
* 数据区（bss，stack，data）
* 与每个活动的内存映射区对应的区域

可以`cat /proc/<pid/maps>`来查看具体进程的内存映射。

当用户空间进程调用mmap时，系统会创建一个新的VMA来相应它。

注意vm\_area\_struct这个重要的数据结构（定义在<linux/mm.h>中）。

## 内存映射处理 ##

系统中每个进程（除了内核空间的辅助线程）都有一个struct mm_struct结构（定义在<linux/sched.h>中），其中包含了大量的内存管理信息。多个进程可以共享内存管理结构，linux就是使用这种方法实现线程的。

## mmap设备操作 ##

mmap可以将用户空间的内存和设备内存映射起来，这样在访问分配地址范围内的内存时就相当于访问设备内存了。

并非所有的设备都能进行mmap抽象：

* 像串口这样面向流的设备就不能
* mmap的另一个限制：必须以PAGE_SIZE为单位进行映射，因为内核只能在页表一级上对虚拟地址进行管理。

为了执行mmap，驱动程序只需要为该地址范围建立合适的页表，并将vma->vm_ops替换为一系列的新操作就可以了。有两种建立页表的方法：使用remap\_pfn\_range函数一次全部建立；通过VMA的fault方法一次建立一个新页表。

## 内存映射的方法 ##

* 重新映射特定的I/O区域
* 重新映射ram
* 重新映射内核虚拟地址
* 执行直接I/O访问

## 分配内存 ##

这里我们来看看内核为设备驱动程序提供的内存管理接口。

### Kmalloc函数 ###

kmalloc内存分配工具和malloc的使用方法很接近。
它的原型是：

`
\#include <linux/slab.h>
void *kmalloc(size_t size, int flags);
`

* flags参数 以多种方式控制kmalloc的行为

最常用的标志是GFP\_KERNEL(GFP的来源是因为kmalloc最终会调用get\_free\_pages函数)，这个标志允许kamlloc在页面不足的情况下休眠。

如果在进程上下文之外使用kmalloc，比如中断处理例程中就需要使用GFP_ATOMIC标志，不会休眠

其他标志都定义在<linux/gfp.h>文件中，请阅读该文件后使用他们

* size参数

内核中使用基于页面的方式管理内存，因此和用户空间的基于堆的简单内存管理有很大的差别

由于slab分配器（即kmalloc的底层实现）最大分配的内存单元是128KB，所以如果分配的内存过大，最好不要使用kmalloc方法

### 高速缓存 ###

内核实现了一些内存池，内核驱动程序通过使用它们可以减少内存分配的次数。

它的api在<linux/slab.h>中，类型为kmem\_cache\_t。

### 内存池 ###

内存池其实是某种形式的高速缓冲，它试图始终保持空闲的状态，方便那些要求内存分配不能失败的代码使用。

它的api在<linux/mempool.h>中，类型为mempool\_t。

### get\_free\_pages和相关函数 ###

如果驱动使用较大块的内存，则适合使用面向页的分配技术。

* get\_zeroed\_page(unsigned int flags);
返回指向新页面的指针并清零

* __get\_free\_page(unsigned int flags);
返回指针但不清零

* __get\_free\_pages(unsigned int flags, unsigned int order);
分配2^order个连续页面，不清零

### 页分配核心 alloc\_pages ###

alloc_pages用来分配描述用struct page描述的页面内存，使用这种结构描述的内核内存在某些地方使用起来非常方便。

struct page *alloc\_pages\_node(int nid, unsigned int flags, unsigned int order);

### vmalloc以及相关函数 ###

vmalloc分配虚拟地址空间的连续内存。尽管可能这段内存在物理上可能不是连续的。

通过vmalloc获得的内存使用起来效率不高，如果可能，应该直接和单个的页面打交道，也就是使用前面的函数来处理而不是使用vmalloc。vmalloc分配的虚拟地址上可能没有物理内存对应。

kmalloc和__get\_free\_pages返回的虚拟地址内存范围与物理内存的范围是一一对应的。但vmalloc和ioremap使用的地址范围则是完全虚拟的，每次分配都需要适当的设置页表来建立内存区域。

ioremap也和vmalloc一样建立新页表，但它不会分配内存。它更多用于映射设备缓冲到虚拟内核空间。值得注意的是不能把ioremap返回的指针直接当作内存使用，应该使用I/O函数来访问。

vmalloc的一个小缺点是它不能在原子上下文中使用。

相关的函数定义在<linux/vmalloc.h>中。

### per-CPU变量 ###

当建立一个per-CPU变量时，系统的每个处理器都会拥有该变量的副本。对于per-CPU变量的访问几乎不需要锁定，因为每个处理器有自己的副本。

注意当处理器在修改某个per-CPU变量的临界区中间时，它可能被抢占，需要避免这种情况发生。所以我们应该显式地调用get\_cpu\_var访问某给定变量的当前处理器副本，结束后调用put\_cpu\_var。

使用方法：

* DEFINE\_PER\_CPU(type, name);
* 动态分配：
void *alloc_percpu(type);
void *\_\_alloc\_percpu(size\_t size, size\_t align);
* per\_cpu\_ptr(void *per\_cpu\_var, int cpu\_id);返回给定cpu\_id的per\_cpu\_var指针
