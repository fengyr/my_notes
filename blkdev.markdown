# 块设备驱动 #

块设备驱动比字符设备驱动要复杂许多，它在I/O操作上表现出极大的不同，缓冲，I/O调度和请求队列等是块设备驱动的主要概念。

块设备I/O的主要操作特点：

* 块设备只能以块为单位进行I/O，字符设备则以字节为单位。大多数设备是字符设备，因为它们不需要缓冲而且不以固定块大小进行操作。
* 块设备对于I/O请求有对应的缓冲，因此它们可以选择以什么顺序进行响应，字符设备无需缓冲且被直接读写。对于存储设备而言调整读写顺序的作用巨大，因为读写连续的扇区比分离的扇区更快。
* 字符设备只能顺序读写，而块设备可以随机访问。虽然块设备可以随机访问，但是对于磁盘这类机械设备而言，顺序的组织设备的访问可以提高性能。注意，对SD卡和RAMDISK等块设备而言，不存在机械上的原因，所以没有必要这样调整。

## Linux块设备的驱动结构 ##

* `struct block_device_operations` 块设备的操作集合，类似于file_operations

* `struct gendisk` 通用磁盘结构体，用于代表一个独立磁盘设备或者分区。gendisk 中包含1个kobject成员，因此，它是一个可被引用计数的结构体。通过`get_disk()`和`put_disk()`函数可用来操作引用计数，这个工作一般不需要驱动亲自做。通常对`del_gendisk()`的调用会去掉gendisk的最终引用计数，但是这一点并不是一定的。因此，在`del_gendisk()`被调用后，这个结构体可能继续存在。

这个结构体将块设备和设备驱动模型联系起来，实现驱动模型中的计数和继承等功能。

* `struct request` 用于描述一次I\O请求。
它的主要成员包括：bio链表和请求链表。

* `struct request_queue` 用于描述请求队列中请求的限制和设定，并记录用于生成请求的函数。最为重要的用它配合I\O调度算法来给请求排序。

* `struct bio` 用于描述块设备传输的最小单元，它主要描述了单次传输的开始扇区和传输的大小。

## 块设备的初始化过程 ##

* `register_blkdev` 分配块设备需要的设备号。
* `blk_init_queue` 分配请求队列
* `alloc_disk` 分配gendisk
* `add_disk` 将gendisk加入设备模型

## 块设备请求 ##

块设备的请求是驱动的核心。

## 资源和链接 ##
[块设备驱动分析，基于sbull](http://www.cnblogs.com/civet/archive/2011/03/14/1983899.html)
